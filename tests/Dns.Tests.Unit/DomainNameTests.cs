// SPDX-FileCopyrightText: 2023 nerve-dns
// 
// SPDX-License-Identifier: BSD-3-Clause

using System.Buffers.Binary;

namespace Nerve.Dns.Tests.Unit;

public class DomainNameTests
{
    // example.com
    private static readonly byte[] ExampleDotComDomainNameBytes =
    {
        0x07, 0x65, 0x78, 0x61, 0x6d, 0x70, 0x6c, 0x65, 0x3, 0x63, 0x6f, 0x6d, 0x00
    };

    // The zero at the end is the index to jump to which comes after the compressed magic byte
    // example.com
    private static readonly byte[] ExampleDotComDomainNameBytesWithCompression =
    {
        0x07, 0x65, 0x78, 0x61, 0x6d, 0x70, 0x6c, 0x65, 0x3, 0x63, 0x6f, 0x6d, 0x00, DomainName.CompressedMagicByte, 0x00
    };

    // example.com and www.example.com
    private static readonly byte[] TwiceExampleDotComDomainNameBytesWithCompression =
    {
        0x07, 0x65, 0x78, 0x61, 0x6D, 0x70, 0x6C, 0x65, 0x03, 0x63, 0x6F, 0x6D, 0x00, 0x03, 0x77, 0x77, 0x77, DomainName.CompressedMagicByte, 0x00
    };

    // Used for the serialization test.
    //
    // This includes a bunch of domains which causes the compression offset for the last example domains to be larger than one byte (255).
    //
    // something.okay, zero.zero, one.one, two.two, three.three, four.four, five.five, six.six,
    // seven.seven, eight.eight, nine.nine, ten.ten, some-really-long-domain-name.de, another-very-long-domain-name.cool,
    // i-need-better-domain-names.org, maybe-this-one-is-really-good.net, example.com, www.example.com
    private static readonly byte[] ManyDomainNamesBytesWithCompression =
    {
        0x09, 0x73, 0x6f, 0x6d, 0x65, 0x74, 0x68, 0x69, 0x6e, 0x67, 0x04, 0x6f, 0x6b, 0x61, 0x79, 0x00, 0x04, 0x7a, 0x65,
        0x72, 0x6f, 0x04, 0x7a, 0x65, 0x72, 0x6f, 0x00, 0x03, 0x6f, 0x6e, 0x65, 0x03, 0x6f, 0x6e, 0x65, 0x00, 0x03, 0x74,
        0x77, 0x6f, 0x03, 0x74, 0x77, 0x6f, 0x00, 0x05, 0x74, 0x68, 0x72, 0x65, 0x65, 0x05, 0x74, 0x68, 0x72, 0x65, 0x65,
        0x00, 0x04, 0x66, 0x6f, 0x75, 0x72, 0x04, 0x66, 0x6f, 0x75, 0x72, 0x00, 0x04, 0x66, 0x69, 0x76, 0x65, 0x04, 0x66,
        0x69, 0x76, 0x65, 0x00, 0x03, 0x73, 0x69, 0x78, 0x03, 0x73, 0x69, 0x78, 0x00, 0x05, 0x73, 0x65, 0x76, 0x65, 0x6e,
        0x05, 0x73, 0x65, 0x76, 0x65, 0x6e, 0x00, 0x05, 0x65, 0x69, 0x67, 0x68, 0x74, 0x05, 0x65, 0x69, 0x67, 0x68, 0x74,
        0x00, 0x04, 0x6e, 0x69, 0x6e, 0x65, 0x04, 0x6e, 0x69, 0x6e, 0x65, 0x00, 0x03, 0x74, 0x65, 0x6e, 0x03, 0x74, 0x65,
        0x6e, 0x00, 0x1c, 0x73, 0x6f, 0x6d, 0x65, 0x2d, 0x72, 0x65, 0x61, 0x6c, 0x6c, 0x79, 0x2d, 0x6c, 0x6f, 0x6e, 0x67,
        0x2d, 0x64, 0x6f, 0x6d, 0x61, 0x69, 0x6e, 0x2d, 0x6e, 0x61, 0x6d, 0x65, 0x02, 0x64, 0x65, 0x00, 0x1d, 0x61, 0x6e,
        0x6f, 0x74, 0x68, 0x65, 0x72, 0x2d, 0x76, 0x65, 0x72, 0x79, 0x2d, 0x6c, 0x6f, 0x6e, 0x67, 0x2d, 0x64, 0x6f, 0x6d,
        0x61, 0x69, 0x6e, 0x2d, 0x6e, 0x61, 0x6d, 0x65, 0x04, 0x63, 0x6f, 0x6f, 0x6c, 0x00, 0x1a, 0x69, 0x2d, 0x6e, 0x65,
        0x65, 0x64, 0x2d, 0x62, 0x65, 0x74, 0x74, 0x65, 0x72, 0x2d, 0x64, 0x6f, 0x6d, 0x61, 0x69, 0x6e, 0x2d, 0x6e, 0x61,
        0x6d, 0x65, 0x73, 0x03, 0x6f, 0x72, 0x67, 0x00, 0x1d, 0x6d, 0x61, 0x79, 0x62, 0x65, 0x2d, 0x74, 0x68, 0x69, 0x73,
        0x2d, 0x6f, 0x6e, 0x65, 0x2d, 0x69, 0x73, 0x2d, 0x72, 0x65, 0x61, 0x6c, 0x6c, 0x79, 0x2d, 0x67, 0x6f, 0x6f, 0x64,
        0x03, 0x6e, 0x65, 0x74, 0x00, 0x07, 0x65, 0x78, 0x61, 0x6d, 0x70, 0x6c, 0x65, 0x03, 0x63, 0x6f, 0x6d, 0x00, 0x03,
        0x77, 0x77, 0x77, 0xc1, 0x0f
    };

    // Used for deserialization test because the then written compression offset is larger than one byte (255).
    //
    // example.com, example.com and www.example.com
    private static readonly byte[] LargeOffsetDomainNameBytesWithCompression =
    {
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x07, 0x65, 0x78, 0x61, 0x6D, 0x70, 0x6C, 0x65, 0x03, 0x63, 0x6F, 0x6D, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x07, 0x65, 0x78, 0x61, 0x6D, 0x70, 0x6C, 0x65, 0x03, 0x63, 0x6F, 0x6D, 0x00, 0x03, 0x77, 0x77, 0x77, DomainName.CompressedMagicByte, 0x00,
    };

    [Fact]
    public void Separator_ReturnsDot()
    {
        // Arrange
        const char expectedSeparator = '.';
        
        // Act
        const char actualSeparator = DomainName.Separator;
        
        // Assert
        actualSeparator.Should().Be(expectedSeparator);
    }

    [Fact]
    public void GetHashCode_DifferentInstancesButSameValue_ReturnsSameHashCode()
    {
        // Arrange
        const string domain = "www.example.com";
        var domainNameFirst = new DomainName(domain);
        var domainNameSecond = new DomainName(domain);
        
        // Act
        int hashCodeFirst = domainNameFirst.GetHashCode();
        int hashCodeSecond = domainNameSecond.GetHashCode();
        
        // Assert
        hashCodeFirst.Should().Be(hashCodeSecond);
    }

    [Fact]
    public void Equals_TwoInstancesWithSameDomain_ReturnsTrue()
    {
        // Arrange
        var domainName = new DomainName("example.com");
        var domainName2 = new DomainName("example.com");
        
        // Act
        bool equals = domainName.Equals(domainName2);
        
        // Assert
        equals.Should().BeTrue();
    }

    [Fact]
    public void Equals_TwoInstancesWithDifferentDomain_ReturnsFalse()
    {
        // Arrange
        var domainName = new DomainName("example.com");
        var domainName2 = new DomainName("example.de");
        
        // Act
        bool equals = domainName.Equals(domainName2);
        
        // Assert
        equals.Should().BeFalse();
    }

    [Fact]
    public void ToString_ValidDomainName_ReturnsCorrectString()
    {
        // Arrange
        var domainName = new DomainName("www.example-domain.com");
        
        // Act
        string text = domainName.ToString();
        
        // Assert
        text.Should().Be("www.example-domain.com");
    }

    [Fact]
    public void ToString_ValidDomainNameWithStartLabelIndex_ReturnsCorrectString()
    {
        // Arrange
        var domainName = new DomainName("www.example-domain.com");
        
        // Act
        string text = domainName.ToString(startLabelIndex: 1);
        
        // Assert
        text.Should().Be("example-domain.com");
    }

    [Fact]
    public void Serialize_WithoutCompression_ReturnsExpectedBytes()
    {
        // Arrange
        byte[] buffer = new byte[13];
        ushort index = 0;
        var domainName = new DomainName("example.com");
        
        // Act
        domainName.Serialize(buffer, ref index, new Dictionary<string, ushort>());
        
        // Assert
        index.Should().Be(13);
        buffer.Should().BeEquivalentTo(ExampleDotComDomainNameBytes);
    }

    [Fact]
    public void Serialize_WithCompression_ReturnsExpectedBytes()
    {
        // Arrange
        byte[] buffer = new byte[19];
        ushort index = 0;
        var domainName = new DomainName("example.com");
        var domainNameSecond = new DomainName("www.example.com");
        var domainNameOffsetCache = new Dictionary<string, ushort>();
        
        // Act
        domainName.Serialize(buffer, ref index, domainNameOffsetCache);
        domainNameSecond.Serialize(buffer, ref index, domainNameOffsetCache);
        
        // Assert
        index.Should().Be(19);
        buffer.Should().BeEquivalentTo(TwiceExampleDotComDomainNameBytesWithCompression);
    }

    [Fact]
    public void Serialize_WithManyDomainNamesAndCompression_ReturnsExpectedBytes()
    {
        // Arrange
        byte[] buffer = new byte[ManyDomainNamesBytesWithCompression.Length];
        ushort index = 0;
        List<DomainName> domainNames = new()
        {
            new DomainName("something.okay"),
            new DomainName("zero.zero"),
            new DomainName("one.one"),
            new DomainName("two.two"),
            new DomainName("three.three"),
            new DomainName("four.four"),
            new DomainName("five.five"),
            new DomainName("six.six"),
            new DomainName("seven.seven"),
            new DomainName("eight.eight"),
            new DomainName("nine.nine"),
            new DomainName("ten.ten"),
            new DomainName("some-really-long-domain-name.de"),
            new DomainName("another-very-long-domain-name.cool"),
            new DomainName("i-need-better-domain-names.org"),
            new DomainName("maybe-this-one-is-really-good.net"),
            // This are the relevant domain names
            // Above is only to have a domain name offset larger than one byte maximum (255)
            new DomainName("example.com"),
            new DomainName("www.example.com"),
        };
        var domainNameOffsetCache = new Dictionary<string, ushort>();
        
        // Act
        foreach (var domainName in domainNames)
        {
            domainName.Serialize(buffer, ref index, domainNameOffsetCache);
        }
        
        // Assert
        index.Should().Be((ushort)ManyDomainNamesBytesWithCompression.Length);
        buffer.Should().BeEquivalentTo(ManyDomainNamesBytesWithCompression);
    }

    [Fact]
    public void Deserialize_WithoutCompression_ReturnsExpectedDomainName()
    {
        // Arrange
        ushort offset = 0;
        var domainName = new DomainName();
        
        // Act
        domainName.Deserialize(ExampleDotComDomainNameBytes, ref offset);
        
        // Assert
        offset.Should().Be(13);
        domainName.Labels.Length.Should().Be(2);
        domainName.ToString().Should().Be("example.com");
    }
    
    [Fact]
    public void Deserialize_WithCompression_ReturnsExpectedDomainName()
    {
        // Arrange
        ushort offset = 13;
        var domainName = new DomainName();
        
        // Act
        domainName.Deserialize(ExampleDotComDomainNameBytesWithCompression, ref offset);
        
        // Assert
        offset.Should().Be(15);
        domainName.Labels.Length.Should().Be(2);
        domainName.ToString().Should().Be("example.com");
    }

    [Fact]
    public void Deserialize_WithManyDomainNamesCompression_ReturnsExpectedDomainName()
    {
        // Arrange
        BinaryPrimitives.WriteUInt16BigEndian(LargeOffsetDomainNameBytesWithCompression.AsSpan(LargeOffsetDomainNameBytesWithCompression.Length - 2, 2), DomainName.CompressedMagicUShort | 0x11D);

        ushort offset = 317;
        var domainName = new DomainName();
        
        // Act
        domainName.Deserialize(LargeOffsetDomainNameBytesWithCompression, ref offset);
        
        // Assert
        offset.Should().Be((ushort)LargeOffsetDomainNameBytesWithCompression.Length);
        domainName.Labels.Length.Should().Be(3);
        domainName.ToString().Should().Be("www.example.com");
    }
}
